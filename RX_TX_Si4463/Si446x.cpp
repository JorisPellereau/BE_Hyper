#include "Si446x.h"
#include "radio_config_Si4463.h"
//#include "radio_config_Si4463_TX.h"

/// Maximum tries to get Clear-to-Send
#define SI_MAX_CTS_TRIES 100 
#define SI_STARTUP_DELAY 12 // 12ms from powerup to CTS
#define SI_PATCH_SIZE 266 // 266 8-byte words



//------------------------------------------------------------------------------
/// @brief      Power-up the device and select the operational mode
///
/// @param      patch_to_apply  SI_PATCH if a patch has been loaded, else SI_NO_PATCH
/// @param      ext_xtal        SI_TCXO: Temperature Calibrated Osc, SI_XTAL: external Xtal
/// @param      xo_freq         Oscillator frequency
///
/// @return     *0xFF*: Booted successfully, *0x00*: No answer from device
///
uint8_t si_power_up(char patch_to_apply, char ext_xtal, unsigned long int xo_freq)
{
	// if(patch_to_apply==SI_PATCH) 
	// 	si_apply_patch(siPatchArray);
	digitalWrite(SI_SS,0); // Select transceiver
	SPI.transfer(SI_POWER_UP); // Boot command
	// Is there a patch to apply before starting the transceiver?
	// Power the chip up into EZRadio PRO functional mode.
	SPI.transfer((patch_to_apply<<7 | SI_PRO)&0xBF); 
	SPI.transfer(ext_xtal&0x01); // Use EXT Xtal or internal OSC
	SPI.transfer((xo_freq>>24)&0xFF); // xo_freq[31:24]
	SPI.transfer((xo_freq>>16)&0xFF); // xo_freq[23:16]
	SPI.transfer((xo_freq>>8)&0xFF); // xo_freq[15:8]
	SPI.transfer(xo_freq&0xFF); // xo_freq[7:0]
	digitalWrite(SI_SS,1);
	delay(SI_STARTUP_DELAY); // Wait for start-up time
	return si_get_cmd(0,0); // Wait for answer
}


//------------------------------------------------------------------------------
/// @brief      Patches the chip's internal MCU
/// - Uses the patch generated by WDS, included in *si446x_patch.h*
/// - My current understanding of the patching process is still rough,
/// so proceed with caution
/// 
/// @param      patchArray  SI_PATCH_SIZE * 8 byte array
///
void si_apply_patch(uint8_t patchArray[][8]) {
	uint16_t patchSize = SI_PATCH_SIZE;
	uint16_t i,j=0;

	digitalWrite(SI_SS,0);
	for(i=0;i<patchSize;i++) {
		SPI.transfer(patchArray[i][j]);
		if(j==8) 
			j=0;
		else
			j++;
	}
	digitalWrite(SI_SS,1);
}


//------------------------------------------------------------------------------
/// @brief      Load pre-built command/property file
/// - The config files are created with SiLabs WDS and
/// are exported to a file named *radio_config.h*
/// - They include the whole startup sequence, modem parameters, etc,
/// and normally too, the patch file if there is one.
///
/// @param      cmdArray  The command array
///
/// @return     *SI_CTS* if data is valid, *0x00* otherwise
///
uint8_t si_load_cfg(uint8_t* cmdArray) {
	uint16_t i=0;
	uint8_t size;
	// cmdArray structure:
	// {length, data[length],
	// length2, data2[length2] etc..
	// 0x00}

	while(cmdArray[i]!=0) { // cmdArray is null-terminated
		digitalWrite(SI_SS,0);
		size = cmdArray[i];
		SPI.transfer(cmdArray+i+1, size);
		digitalWrite(SI_SS, 1);
		if(si_get_cmd(0,0) != SI_CTS) return 0;
		i=i+size+1; // Prepare next command
	}
	return SI_CTS;
}

//------------------------------------------------------------------------------
/// @brief      Get response from Si446x
///
/// @param      buffer_size  size of the expected reply buffer
/// @param      cmdbuf  will be filled with the reply     
///
/// @return     *SI_CTS* if data is valid, *0x00* otherwise
///
uint8_t si_get_cmd(uint8_t buffer_size, uint8_t* cmdbuf) {
	uint8_t recv = 0;
	uint16_t i = SI_MAX_CTS_TRIES;

	for(; (i>0) && (recv!=SI_CTS); i--) {
		digitalWrite(SI_SS, 1);
		digitalWrite(SI_SS, 0);
		SPI.transfer(SI_READ_CMD_BUFF);
		recv = SPI.transfer(0);
		if(recv==0) delayMicroseconds(200);
	}
	if((buffer_size==0)||(cmdbuf==0)) {
		digitalWrite(SI_SS, 1);
		return recv;
	}
	for(i=buffer_size; i>0; i--) {
		cmdbuf[buffer_size - i] = SPI.transfer(0);
	}
	digitalWrite(SI_SS, 1);
	return recv;
}

//------------------------------------------------------------------------------
/// @brief      Get chip info:
/// 
/// @param      infobuf  8-byte array with the chip info
/// - CHIPREV[7:0] - Chip Mask Revision
/// - PART[15:0] - Part Number. (e.g. Si4461 will return - 0x4461)
/// - PBUILD[7:0] - Part Build
/// - ID[15:0] - ID
/// - CUSTOMER[7:0] - Customer ID
/// - ROMID[7:0] - ROM ID
///
/// @return     *SI_CTS* if data is valid, *0x00* otherwise
///
uint8_t si_get_info(uint8_t* infobuf) {
	digitalWrite(SI_SS,0);
	SPI.transfer(SI_PART_INFO); // Get info cmd
	digitalWrite(SI_SS,1);
	return si_get_cmd(8, infobuf); // Read back info
}


//------------------------------------------------------------------------------
/// @brief      Get currently loaded revision info
///
/// @param      funcbuf  6-byte array with rev. info
/// 
/// - REVEXT[7:0]
/// 	+ External revision number
///		+ Range: 0 to 255
/// - REVBRANCH[7:0] - Branch revision number
/// 	+ Range: 0 to 255
/// - REVINT[7:0] - Internal revision number
/// 	+ Range: 0 to 255
/// - PATCH[15:0]
/// 	+ ID of applied patch. This is also the last 2 bytes in the associated patch file (*.csg).
/// 	+ 0x0000 = No patch applied.
/// - FUNC[7:0] - Current functional mode
/// 	+ 0 = Part is currently in boot mode
/// 	+ 1 = Part is currently running main application image.
///
/// @return     *SI_CTS* if data is valid, *0x00* otherwise
///
uint8_t si_get_func(uint8_t* funcbuf) {
	digitalWrite(SI_SS,0);
	SPI.transfer(SI_FUNC_INFO); // Get info cmd
	digitalWrite(SI_SS,1);
	return si_get_cmd(6, funcbuf); // Read back info
}


//------------------------------------------------------------------------------
/// @brief      Reads count
///
/// @param      fifoInfoBuf  Contains fifo info:
/// 
///- RX_FIFO_COUNT[7:0] - Amount of bytes stored in receive fifo
///- TX_FIFO_SPACE[7:0] - Amount of space currently available in transmit fifo.
///
/// @return     *SI_CTS* if data is valid, *0x00* otherwise
///
uint8_t si_fifo_info(uint8_t* fifoInfoBuf) {
	digitalWrite(SI_SS,0);
	SPI.transfer(SI_FIFO_INFO); // Get fifo info cmd
	digitalWrite(SI_SS,1);
	return si_get_cmd(2, fifoInfoBuf); // Read back info
}


//------------------------------------------------------------------------------
/// @brief      Write bytes to Transmit fifo
///
/// @param      size       Number of bytes to be transferred (up to 64 per command call)
/// @param      fifobytes  Byte array to transmit
/// 
/// - This command has no response/CTS to be read. 
/// If you write more data than the TX FIFO can hold, 
/// it will trigger a FIFO Overflow interrupt: FIFO_UNDERFLOW_OVERFLOW_ERROR
///
void si_fifo_write(uint8_t size, uint8_t* fifobytes) {
	uint8_t i;

	digitalWrite(SI_SS,0);
	SPI.transfer(SI_WRITE_TX_FIFO);
	for(i=size;i>0;i--) {
		SPI.transfer(fifobytes[size-i]); 
	}
	digitalWrite(SI_SS,1);
}


//------------------------------------------------------------------------------
/// @brief      Read bytes from Receive fifo
///
/// @param      size       Number of bytes to be read 
/// @param      fifobytes  Read bytes are stored in this array
///
/// - This command has no CTS to be read. 
/// If you read more data than the RX FIFO has currently stored,
/// it will trigger a FIFO Underflow interrupt: FIFO_UNDERFLOW_OVERFLOW_ERROR
///
void si_fifo_read(uint8_t size, uint8_t* fifobytes) {
	uint8_t i;

	digitalWrite(SI_SS,0);
	SPI.transfer(SI_READ_RX_FIFO); 
	for(i=size;i>0;i--) {
		fifobytes[size-i] = SPI.transfer(0); 
	}
	digitalWrite(SI_SS,1);
}


//------------------------------------------------------------------------------
/// @brief      Read Fast-Response register(s)
///
/// @param      frrId     The frr identifier:
/// + SI_FRR_A
/// + SI_FRR_B
/// + SI_FRR_C
/// + SI_FRR_D
/// - SI_FRR_ALL: To read the 4 registers at once
/// @param      frrBytes  Byte array to store FRRs
///
/// @return     No CTS for this command
///
void si_read_frr(uint8_t frrId, uint8_t* frrBytes) {
	uint8_t i;

	if((frrId!=SI_FRR_A)||(frrId!=SI_FRR_B)||(frrId!=SI_FRR_C)||(frrId!=SI_FRR_D)||(frrId!=SI_FRR_ALL))
		return;

	digitalWrite(SI_SS,0);
	if(frrId==SI_FRR_ALL) {
		SPI.transfer(SI_FRR_A);
		for(i=4;i>0;i--) {
			frrBytes[4-i] = SPI.transfer(0);
		}
	}
	else {
		SPI.transfer(SI_FRR_A);
		frrBytes[0] = SPI.transfer(0);
	}
	digitalWrite(SI_SS,1);
}


//------------------------------------------------------------------------------
/// @brief      Request device state and tuned channel
///
/// @param      stateBuf  Buffer to write state/channel info:
/// - CURR_STATE[7..0] : Current state 
/// 	+ SI_SLEEP : SLEEP or STANDBY state, according to the mode of operotion of the 32K R-C Osc selected by GLOBAL_CLK_CFG:CLK_32K_SEL.
/// 	+ SI_SPI_ACTIVE : SPI ACTIVE state.
/// 	+ SI_READY : READY state.
/// 	+ SI_READY2 : Another enumeration for READY state.
/// 	+ SI_TX_TUNE : TX_TUNE state.
/// 	+ SI_RX_TUNE : RX_TUNE state.
/// 	+ SI_TX  : TX state.
/// 	+ SI_RX  : RX state.
/// - CURRENT_CHANNEL[7..0] : Current channel number
///
/// @return     *SI_CTS* if data is valid, *0x00* otherwise
///
uint8_t si_state_info(uint8_t* stateBuf) {
	digitalWrite(SI_SS,0);
	SPI.transfer(SI_REQUEST_DEVICE_STATE);
	digitalWrite(SI_SS,1);
	return si_get_cmd(2, stateBuf); // Read back info
}


//------------------------------------------------------------------------------
/// @brief      Manually change transceiver state
/// 
/// The chip normally manages the required steps in transitioning between operating 
/// states automatically. For example, transmission of a packet may require: 
/// waking the chip from SLEEP mode, enabling the Xtal Oscillator (READY mode), 
/// calibrating the VCO and tuning the PLL Synthesizer (TX_TUNE mode), 
/// enabling the PA and transmission of the packet (TX mode), and returning to an IDLE state. 
/// This sequencing is normally handled by the internal state machine.
/// This command provides for manually switching to a desired operating state.
/// This command may be used to enter TX or RX mode, if desired. 
/// However, those modes of operation typically require specification of additional parameters
///  (e.g., channel number, number of packet bytes, etc.) prior to switching mode. 
///  For this reason, separate START_TX and START_RX commands are provided that essentially accomplish 
///  the CHANGE_STATE = TX or RX functionality, while simultaneously passing the required parameter bytes.
///
/// @param      nextState  The next wanted state:
/// 	+ SI_NOCHANGE : Do not change from previously sent TXCOMPLETE_STATE. (No Change does not have the effect of remaining in TX mode.)
/// 	+ SI_SLEEP : SLEEP or STANDBY state, according to the mode of operotion of the 32K R-C Osc selected by GLOBAL_CLK_CFG:CLK_32K_SEL.
/// 	+ SI_SPI_ACTIVE : SPI ACTIVE state.
/// 	+ SI_READY : READY state.
/// 	+ SI_READY2 : Another enumeration for READY state.
/// 	+ SI_TX_TUNE : TX_TUNE state.
/// 	+ SI_RX_TUNE : RX_TUNE state.
/// 	+ SI_TX  : TX state.
/// 	+ SI_RX  : RX state.
///
/// @return     *SI_CTS* if data is valid, *0x00* otherwise
///
uint8_t si_state_change(uint8_t nextState) {
	nextState&=0x0F; // State on 4 bits
	digitalWrite(SI_SS,0);
	SPI.transfer(SI_CHANGE_STATE);
	SPI.transfer(nextState);
	digitalWrite(SI_SS,1);
	return si_get_cmd(0, 0); 
}


//------------------------------------------------------------------------------
/// @brief      Get/clear Chip Interrupts
///
/// @param      clearId         Interrupt flags to clear, set to *0* to clear all:
/// - SI_WUT
/// - SI_LOW_BATT
/// - SI_CHIP_READY
/// - SI_CMD_ERROR
/// - SI_STATE_CHANGE
/// - SI_FIFO_UNDERFLOW_OVERFLOW_ERROR 
/// - SI_CAL
/// 
/// @param      chipInterrupts 4-byte array:
/// - CHIP_PEND : Pending (latched) interrupts 
/// - CHIP_STATUS : Currently active Interrupt events
/// - CMD_ERR_STATUS : Last command error cause. Only valid if CMD_ERROR status bit is set:
/// 	+ CMD_ERROR_NONE : No error. 	
/// 	+ CMD_ERROR_BAD_COMMAND : Bad command issued. 	
/// 	+ CMD_ERROR_BAD_ARG : Argment(s) in issued command were invalid. 	
/// 	+ CMD_ERROR_COMMAND_BUSY : Command was issued before previous command was completed. 	
/// 	+ CMD_ERROR_BAD_BOOTMODE : Invalid bootmode supplied. 	
/// 	+ CMD_ERROR_BAD_PROPERTY : Bad Property ID was provided.
/// - CMD_ERR_CMD_ID : Command ID that was being proccessed at the time of the last command error.
///
/// @return     *SI_CTS* if data is valid, *0x00* otherwise
///
uint8_t si_status_chip(uint8_t clearId, uint8_t* chipInterrupts) {
	digitalWrite(SI_SS,0);
	SPI.transfer(SI_GET_CHIP_STATUS);
	if(clearId != 0) {
		SPI.transfer(clearId);
	}
	digitalWrite(SI_SS,1);
	return si_get_cmd(4, chipInterrupts);
}


//------------------------------------------------------------------------------
/// @brief      Get modem Interrupts and RSSI value
///
/// @param      clearId      Interrupt flags to clear, set to *0* to clear all:
/// - INVALID_SYNC
/// - RSSI_JUMP
/// - RSSI
/// - INVALID_PREAMBLE
/// - PREAMBLE_DETECT
/// - SYNC_DETECT
/// 
/// @param      modemStatus  8-byte array: (in order)
/// - MODEM_PEND[7:0] - Latched interrupts
/// - MODEM_STATUS[7:0] - Currently active interrupts
/// - CURR_RSSI[7:0] - Current RSSI reading from the modem.
/// - LATCH_RSSI[7:0] - Latched RSSI reading from the modem 
/// as configured by MODEM_RSSI_CONTROL. Reset to 0 at the start of every RX.
/// - ANT1_RSSI[7:0] - RSSI of ANT1 while antenna diversity. Latched during 
/// preamble evaluation and avaliable for reading after sync detection.
/// - ANT2_RSSI[7:0] - RSSI of ANT2 while antenna diversity. Latched during 
/// preamble evaluation and avaliable for reading after sync detection.
/// - AFC_FREQ_OFFSET[15:0] - The AFC value that is generated by the AFC loop during receive mode.
///
/// @return     *SI_CTS* if data is valid, *0x00* otherwise
///
uint8_t si_status_modem(uint8_t clearId, uint8_t* modemStatus) {
  Serial.print("Dans si_status_modem");
  Serial.println("");
	digitalWrite(SI_SS,0);
	SPI.transfer(SI_GET_MODEM_STATUS);
	if(clearId != 0) {
		SPI.transfer(clearId);
	}
	digitalWrite(SI_SS,1);
	return si_get_cmd(8, modemStatus);
}


//------------------------------------------------------------------------------
/// @brief      Get/clear Packet Handler Interrupts
///
/// @param      clearId   Interrupt flags to clear, set to *0* to clear all:
/// - FILTER_MATCH - If set, incoming packet matched filter.
/// - FILTER_MISS - If set, incoming packet was discarded because filter did not match
/// - PACKET_SENT - If set, Packet Sent
/// - PACKET_RX - If set, Packet Received
/// - CRC_ERROR - If set, CRC-32 error
/// - TX_FIFO_ALMOST_EMPTY - If set, TX fifo is below watermark
/// - RX_FIFO_ALMOST_FULL - If set, RX fifo is above watermark
///
/// @param      phStatus  2-byte array:
/// - PH_PEND[7:0] - Latched packet handler interrupts
/// - PH_STATUS[7:0] - Currently active interrupts
///
/// @return     *SI_CTS* if data is valid, *0x00* otherwise
///
uint8_t si_status_ph(uint8_t clearId, uint8_t* phStatus) {
	digitalWrite(SI_SS,0);
	SPI.transfer(SI_GET_PH_STATUS);
	if(clearId != 0) {
		SPI.transfer(clearId);
	}
	digitalWrite(SI_SS,1);
	return si_get_cmd(2, phStatus);
}


//------------------------------------------------------------------------------
/// @brief      Get/clear All Interrupts
///
/// @param      clearIds   3-byte array of Interrupt flags to clear, set to *0* to clear all:
///  - PH_CLR[7:0] - See flags at si_status_ph()
///  - MODEM_CLR[7:0] - See flags at si_status_modem()
///  - CHIP_CLR[7:0] - See flags at si_status_chip()
///  
/// @param      intStatus  8-byte array with all pending/active interrupts:
/// - INT_PEND[7:0] - Latched group interrupts:
/// 	+ CHIP_INT_STATUS - A chip interrupt has occurred
/// 	+ MODEM_INT_STATUS - A modem interrupt has occurred
/// 	+ PH_INT_STATUS - A packet handler interrupt has occurred
/// - INT_STATUS[7:0] - Currently active group interrupts
/// - PH_PEND[7:0]
/// - PH_STATUS[7:0]
/// - MODEM_PEND[7:0]
/// - MODEM_STATUS[7:0]
/// - CHIP_PEND[7:0]
/// - CHIP_STATUS[7:0]
///
/// @return     *SI_CTS* if data is valid, *0x00* otherwise
///
uint8_t si_status(uint8_t* clearIds, uint8_t* intStatus) {
	digitalWrite(SI_SS,0);
	SPI.transfer(SI_GET_INT_STATUS);
	if(clearIds != 0) {
		SPI.transfer(clearIds[0]);
		SPI.transfer(clearIds[1]);
		SPI.transfer(clearIds[2]);
	}
	digitalWrite(SI_SS,1);
	return si_get_cmd(8, intStatus);
}


//------------------------------------------------------------------------------
/// @brief      Set property(ies)
/// - This command sets the value of one or more properties. 
/// Properties are similar to parameters passed to an API command, 
/// but are not expected to change frequently. 
/// - They are typically used to configure the operation of various internal circuit blocks.
/// Properties may be controlled by higher layers of the user's software. 
/// Setting some properties may not cause the device to take immediate action; 
/// however, the property will take effect once a command which uses that property is issued.
/// - Properties that affect similar circuit blocks or functions 
/// (e.g., MODEM or PA or SYNTH properties) are grouped together 
/// and share the same GROUP parameter value. Each property within 
/// that GROUP has a different offset number or index.
///
/// @param      propGroup  Property group
/// @param      numProps   Number of properties to be set (Max. 12 at a time)
/// @param      startProp  First property index (address)
/// @param      propData   numProp-length byte array storing the property values
///
/// @return     *SI_CTS* if data is valid, *0x00* otherwise
///
uint8_t si_property_set(uint8_t propGroup, uint8_t numProps, uint8_t startProp, uint8_t* propData) {
	uint8_t i;
	if(numProps>12) numProps = 12; // No more than 12 properties per transaction

	digitalWrite(SI_SS,0);
	SPI.transfer(SI_SET_PROPERTY);
	SPI.transfer(propGroup); // Set group
	SPI.transfer(numProps); // Set num of properties to be set
	SPI.transfer(startProp); // Set start index
	for(i=numProps;i>0;i--) {
		SPI.transfer(propData[numProps-i]); 
	}
	digitalWrite(SI_SS,1);
	return si_get_cmd(0, 0); // Get CTS
}


//------------------------------------------------------------------------------
/// @brief      Get property(ies)
/// - This command retrieves the value of one or more properties. 
/// Properties are similar to parameters passed to an API command, 
/// but are not expected to change frequently. 
/// - They are typically used to configure the operation of various 
/// internal circuit blocks. The returned value represents 
/// the default property value upon si_power_up() or the value 
/// set previously with a si_property_set() command.
/// - Properties that affect similar circuit blocks or functions 
/// (e.g., MODEM or PA or SYNTH properties) are grouped together 
/// and share the same GROUP parameter value. Each property within 
/// that GROUP has a different offset number or index.
///
/// @param      propGroup  Property group
/// @param      numProps   Number of properties to be read (Max. 16 at a time)
/// @param      startProp  First property index (address)
/// @param      propData   numProp-length byte array for storing the property values
///
/// @return     *SI_CTS* if data is valid, *0x00* otherwise
///
uint8_t si_property_get(uint8_t propGroup, uint8_t numProps, uint8_t startProp, uint8_t* propData) {
	uint8_t i;
	if(numProps>16) numProps = 16; // No more than 16 properties per transaction

	digitalWrite(SI_SS,0);
	SPI.transfer(SI_GET_PROPERTY);
	SPI.transfer(propGroup); // Set group
	SPI.transfer(numProps); // Set num of properties to be retrieved
	SPI.transfer(startProp); // Set start index
	digitalWrite(SI_SS,1);
	return si_get_cmd(numProps, propData); // Get CTS and retrieve properties
}


//------------------------------------------------------------------------------
/// @brief      Get ADC conversion values
/// - The chip provides an Auxiliary Analog-to-Digital Converter (ADC) 
/// for the purpose of measuring various analog parameters and returning 
/// their values in digital form. The ADC utilizes a Successive Approximation 
/// Register (SAR) architecture and achieves 11-bit resolution, with a 9-bit 
/// Effective Number of Bits (ENOB).
/// - The ADC may be configured to measure the internal battery voltage, 
/// an internal temperature sensor, or an external voltage applied to a selected GPIO pin. 
/// More than one type of measurement may be enabled at the same time; 
/// the conversions will be performed sequentially and all converted values returned.
/// - The ADC is capable of converting any battery voltage within the chip's operating supply voltage range of 1.8VDC to 3.6VDC.
/// - The GPIO pin carrying the external voltage to be measured is selected by the ADC_GPIO_PIN parameter, 
/// and must also be configured as an input pin or tri-state pin (through the si_gpio_cfg() command).
/// 
/// @param      sources  Select ADC Sources and (if used) GPIO pin number:
/// - ADC_TEMPERATURE
/// - ADC_BATTERY_VOLTAGE
/// - ADC_GPIO
/// - ADC_GPIO_PIN[1:0] - GPIO pin number 0-3
/// @param      adcData  6-byte array of 11-bit conversion values:
/// - GPIO_ADC[15:0]
/// - BATTERY_ADC[15:0]
/// 	+ VBAT(V) = 3*BATTERY_ADC/1280.
/// - TEMP_ADC[15:0]
/// 	+ TEMP(degC) = (899/4096)*TEMP_ADC - 293.
/// 
/// @return     *SI_CTS* if data is valid, *0x00* otherwise
/// 
uint8_t si_adc_read(uint8_t sources, uint8_t* adcData) {
	digitalWrite(SI_SS,0);
	SPI.transfer(SI_GET_ADC_READING);
	SPI.transfer(sources); // Select sources of conversion
	digitalWrite(SI_SS,1);
	return si_get_cmd(6, adcData); // Get CTS and retrieve conversion values
}


//------------------------------------------------------------------------------
/// @brief      Get received (variable) packet length
/// - This function can be extended to quickly reconfigure
/// variable-length packets, see datasheet/API for more info
///
/// @param      packetLen  2-byte array containing 16-bit packet length
///
/// @return     *SI_CTS* if data is valid, *0x00* otherwise
///
uint8_t si_packet_info(uint8_t* packetLen) {
	digitalWrite(SI_SS,0);
	SPI.transfer(SI_PACKET_INFO);
	// SPI.transfer(newLenghtParams, 5); // Set new variable packet length (see datasheet)
	digitalWrite(SI_SS,1);
	return si_get_cmd(2, packetLen); // Get CTS and retrieve received packet size
}


//------------------------------------------------------------------------------
/// @brief      Image Rejection Calibration
/// Performs image rejection calibration. Completion can be monitored 
/// by polling CTS or waiting for CHIP_READY interrupt source.
/// - See Si446x revC2 datasheet/API to set parameters
///
/// @param      stepSize  
/// @param      rssiAvg   
/// @param      rxSet1    
/// @param      rxSet2    
///
/// @return     *SI_CTS* if data is valid, *0x00* otherwise
///
uint8_t si_ir_cal(uint8_t stepSize, uint8_t rssiAvg, uint8_t rxSet1, uint8_t rxSet2) {
	digitalWrite(SI_SS,0);
	SPI.transfer(SI_IRCAL);
	SPI.transfer(stepSize);
	SPI.transfer(rssiAvg);
	SPI.transfer(rxSet1);
	SPI.transfer(rxSet2);
	digitalWrite(SI_SS,1);
	return si_get_cmd(0, 0); // Get CTS
}


//------------------------------------------------------------------------------
/// @brief      Puts the radio in TX mode
/// - Doesn't use any parameters, as the values are stored in RAM:
/// - Use si_tx_cfg() to set the parameters (channel, delay etc..)
///
/// @return     *SI_CTS* when the chip has entered TX state, else *0*
///
uint8_t si_tx_start(void) {
	digitalWrite(SI_SS,0);
	SPI.transfer(SI_START_TX);
	digitalWrite(SI_SS,1);
	return si_get_cmd(0, 0); // Get CTS
}


//------------------------------------------------------------------------------
/// @brief      Update radio TX mode parameters
///
/// @param      channel     Channel number
/// @param      nextState   State to put radio after a packet has been sent
/// @param      retransmit  1: retransmit prev. packet, 0: transmit next packet in FIFO
/// @param      length      12-bit packet length (you can leave it at *0*)
/// @param      pktDelay    Delay (in us) before sending next packet
/// @param      pktRepeat   Number of times to repeat the current packet: does not repeat Sync/Preamble
///
/// @return     *SI_CTS* if data is valid, *0x00* otherwise
///
uint8_t si_tx_cfg(uint8_t channel, uint8_t nextState, uint8_t retransmit, uint16_t length, uint8_t pktDelay, uint8_t pktRepeat) {
	digitalWrite(SI_SS,0);
	SPI.transfer(SI_START_TX);
	SPI.transfer(channel);
	SPI.transfer((nextState<<4) | 0x08 | (retransmit<<2)); // Only update settings, do not start transmission
	SPI.transfer(length>>8);
	SPI.transfer(length&0xFF);
	SPI.transfer(pktDelay);
	SPI.transfer(pktRepeat);
	digitalWrite(SI_SS,1);
	return si_get_cmd(0, 0); // Get CTS
}


//------------------------------------------------------------------------------
/// @brief      Start reception of a packet
/// - Uses parameters set with si_rx_cfg() (parameters are retained during *sleep* mode too)
///
/// @return     *SI_CTS* if radio has entered RX, *0x00* otherwise
///
uint8_t si_rx_start(void) {
	digitalWrite(SI_SS,0);
	SPI.transfer(SI_START_RX);
	digitalWrite(SI_SS,1);
	return si_get_cmd(0, 0); // Get CTS
}


//------------------------------------------------------------------------------
/// @brief      Update radio RX mode parameters
///
/// @param      channel       Channel number
/// @param      length        12-bit packet length value (can be set to 0 to use default length)
/// @param      timeoutState  State to enter after RX Timeout (set to 0 to stay in RX)
/// @param      validState    State to enter after a valid packet is received (set to 0 to stay in RX)
/// @param      invalidState  State to enter after an invalid packet is received (set to 0 to stay in RX)
///
/// @return     *SI_CTS* if radio has entered RX, *0x00* otherwise
///
uint8_t si_rx_cfg(uint8_t channel, uint16_t length, uint8_t timeoutState, uint8_t validState, uint8_t invalidState) {
	digitalWrite(SI_SS,0);
	SPI.transfer(SI_START_RX);
	SPI.transfer(channel);
	SPI.transfer(0x08); // Only update settings, do not start reception
	SPI.transfer(uint8_t(length>>8));
	SPI.transfer(length&0xFF);
	SPI.transfer(timeoutState);
	SPI.transfer(validState);
	SPI.transfer(invalidState);
	digitalWrite(SI_SS,1);
	return si_get_cmd(0, 0); // Get CTS
}

//------------------------------------------------------------------------------
/// @brief      Configure GPIO, SDO and nIRQ pins
/// Use SI_GPIO_xxxx prefix for all the defined values, e.g. SI_GPIO_TRISTATE
///
/// @param      gpioSet        4-byte array with GPIO config:
/// - Pullup config bit: PULL_SET
/// 
/// - DONOTHING - Behavior of this pin is not modified.
/// - TRISTATE - Input and output drivers disabled.
/// - DRIVE0 - Pin is configured as a CMOS output and driven low.
/// - DRIVE1 - Pin is configured as a CMOS output and driven high.
/// - INPUT - Pin is configured as a CMOS input. This is used for all GPIO functions that require the pin to be an input (e.g., TXDATA input for TX Direct Mode). However, configuration of this pin as an input does NOT additionally select which internal circuit receives that input; that functionality is controlled by other properties, as appropriate.
/// - 32K_CLK - Outputs 32 kHz clock selected using GLOBAL_CLK_CFG:CLK_32K_SEL. Output low if the 32 kHz clock is not enabled.
/// - BOOT_CLK - Outputs the boot clock signal. This signal will only be present when the chip is in the SPI_ACTIVE state as that is the only state in which the boot clock is active.
/// - DIV_CLK - Outputs the divided clock signal (or the divided boot clock signal in SPI ACTIVE state). This output is low while the chip is in SLEEP state as the source (e.g., the Xtal Oscillator) for the divided clock signal is not running, and outputs the divided XtalOsc signal in all other states. The divider is configured using the GLOBAL_CLK_CFG:DIVIDED_CLK_SEL.
/// - CTS - Clear To Send signal. This output goes high when the command handler is able to receive a new command, and is low otherwise.
/// - INV_CTS - Inverted Clear To Send signal. This output goes low when clear to send a new command, and is high otherwise.
/// - CMD_OVERLAP - This output is low unless a command overlap occurs (i.e., another command is sent before the command handler completes processing a previous command). When command overlap occurs, this output goes high until the rising edge of CTS.
/// - SDO - Outputs the Serial Data Out (SDO) signal for the SPI bus.
/// - POR - This output goes low during Power-On Reset and goes high upon completion of POR.
/// - CAL_WUT - This output is normally low, and pulses high for one cycle of the 32 kHz clock upon expiration of the Calibration Timer. The 32 kHz clock must be enabled in order to use the Calibration Timer. The Calibration Timer period is configured using GLOBAL_WUT_CONFIG:WUT_CAL_PERIOD and enabled by GLOBAL_WUT_CONFIG:CAL_EN.
/// - WUT - This output is normally low, and pulses high for 2(WUT_R+1) cycles of the 32 kHz clock upon expiration of the Wake-Up Timer (WUT). The 32 kHz clock must be enabled in order to use the WUT. The period of the WUT is configured using GLOBAL_WUT_M, and GLOBAL_WUT_R and enabled by GLOBAL_WUT_CONFIG:WUT_EN.
/// - EN_PA - This output goes high when the internal PA is enabled.
/// - TX_DATA_CLK - Outputs the TX Data Clock signal. This signal is a square wave at the selected TX data rate, and is intended for use in TX Direct Synchronous Mode (i.e., in conjunction with a pin configured for TX Data Input).
/// - RX_DATA_CLK - Outputs the RX Data CLK signal. This signal is nominally a square wave that is synchronized to the received data rate, and is typically used to latch the RX Data signal into the host MCU.
/// - EN_LNA - This output goes low when the internal LNA is enabled.
/// - TX_DATA - Outputs the TX data bits pulled from the TX FIFO and sent to the TX modulator. This is an output signal (primarily for diagnostic purposes) and is NOT used as an input for TX Direct Sync/Async mode.
/// - RX_DATA - Outputs the demodulated RX Data stream, after synchronization and re-timing by the local RX Data Clock.
/// - RX_RAW_DATA - Outputs the demodulated RX Raw Data stream, prior to synchronization and re-timing by the local RX Data Clock.
/// - ANTENNA_1_SW - Antenna-1 Switch signal used for control of an RF switch during Antenna Diversity operation. This signal normally assumes the complementary polarity of the Antenna-2 Switch signal (except during SLEEP state).
/// - ANTENNA_2_SW - Antenna-2 Switch signal used for control of an RF switch during Antenna Diversity operation. This signal normally assumes the complementary polarity of the Antenna-1 Switch signal (except during SLEEP state).
/// - VALID_PREAMBLE - This output goes high when a valid preamble is detected, and returns low after the packet is received or Sync Word timeout occurs.
/// - INVALID_PREAMBLE - Output low normally, pulses output high when the preamble is not detected within a period time (determined by PREAMBLE_CONFIG_STD_2:RX_PREAMBLE_TIMEOUT) after the demodulator is enabled.
/// - SYNC_WORD_DETECT - This output goes high when a Sync Word is detected, and returns low after the packet is received.
/// - CCA - Clear Channel Assessment. This output goes high when the Current RSSI signal exceeds the threshold value set by the MODEM_RSSI_THRESH property, and is low when the Current RSSI is below threshold. This is a real-time (non-latched) signal.
/// - IN_SLEEP - This output goes high when the chip is NOT in SLEEP state, and goes low when in SLEEP state.
/// - TX_STATE - This output is set high while in TX state and is low otherwise. The TX_STATE and RX_STATE signals are typically used for control of peripheral circuits (e.g., a T/R Switch).
/// - RX_STATE - This output is set high while in RX state and is low otherwise. The TX_STATE and RX_STATE signals are typically used for control of peripheral circuits (e.g., a T/R Switch).
/// - RX_FIFO_FULL - This output is high while the number of bytes stored in the RX FIFO exceeds the threshold value set by the PKT_RX_THRESHOLD property, and is low otherwise.
/// - TX_FIFO_EMPTY - This output is high while the number of bytes of empty space in the TX FIFO exceeds the threshold value set by the PKT_TX_THRESHOLD property, and is low otherwise.
/// - LOW_BATT - This output is high while the battery voltage drops below the threshold value set by the GLOBAL_LOW_BATT_THRESH property, and is low otherwise. 	
/// - CCA_LATCH - This output goes high if the Current RSSI signal exceeds the threshold value set by the MODEM_RSSI_THRESH property and remains high (i.e., is latched) even if the Current RSSI signal subsequently drops below the threshold value. The signal returns low upon detection of the Sync Word or upon exiting RX state.
/// - HOPPED - This output toggles (i.e., switches from low to high, or high to low) whenever an automatic hop within the RX Hop Table occurs. This signal is not affected by a manual hop initiated through the RX_HOP command. 	
/// - HOP_TABLE_WRAP - This output toggles (i.e., switches from low to high, or high to low) whenever the automatic hop table wraps. This signal is not affected by a manual hop initiated through the RX_HOP command.
///
/// @param      nIrq           nIRQ pin configuration: 
/// check API to see which GPIO modes are supported, plus:
/// - NIRQ - Active low interrupt signal
/// 
/// @param      sdo            SDO pin configuration
/// check API to see which GPIO modes are supported
/// 
/// @param      driveStrength  Output drive strength:
/// - SI_GPIO_DRV_HIGH 
/// - SI_GPIO_DRV_MED_HIGH 
/// - SI_GPIO_DRV_MED_LOW 
/// - SI_GPIO_DRV_LOW
/// 
/// @param 		gpioData       7-byte array containing read GPIO pin levels and modes:
/// - GPIO[0] : GPIO_STATE bit and GPIO_MODE[5:0]
/// - GPIO[1] : GPIO_STATE bit and GPIO_MODE[5:0]
/// - GPIO[2] : GPIO_STATE bit and GPIO_MODE[5:0]
/// - GPIO[3] : GPIO_STATE bit and GPIO_MODE[5:0]
/// - NIRQ : NIRQ_STATE bit and NIRQ_MODE[5:0]
/// - SDO : SDO_STATE bit and SDO_MODE[5:0]
/// - STRENGTH
/// 
/// @return     *SI_CTS* if data is valid, *0x00* otherwise
///
uint8_t si_gpio_cfg(uint8_t* gpioSet, uint8_t nIrq, uint8_t sdo, uint8_t driveStrength, uint8_t* gpioData) {
	digitalWrite(SI_SS,0);
	SPI.transfer(SI_GPIO_PIN_CFG);
	SPI.transfer(gpioSet, 4); // Set the 4 GPIOs' modes' and pullups
	SPI.transfer(nIrq); // Set nIRQ pin mode and pullup
	SPI.transfer(sdo); // Set SDO pin mode and pullup
	SPI.transfer(driveStrength); // Set output drive strength
	digitalWrite(SI_SS,1);
	return si_get_cmd(7, gpioData); // Get CTS and retrieve gpio states
}


// == Fonctions ajoutées 

// == Gestion SDN ==
void cmd_SDN() {
  digitalWrite(SI_SDN, LOW);
  digitalWrite(SI_SDN, HIGH);
  delay(1);
  digitalWrite(SI_SDN, LOW);
}
// ===============

// == Lecture_CTS ==
uint8_t read_cts() {
        uint8_t recv = 10;
        digitalWrite(SI_SS, 1);
        digitalWrite(SI_SS, 0);
        SPI.transfer(SI_READ_CMD_BUFF);
        recv = SPI.transfer(0);
        if(recv == SI_CTS) {
        Serial.println("CTS Reçu");
        }
        else {
          Serial.println("CTS non reçu");
          recv = 10;
        }
        digitalWrite(SI_SS, 1);
        return recv;
}
// ================

// == Lecture etat Chip ==
void lecture_state_info(uint8_t *stateBuf,  char *state_chip) {
    char i;
    //char *state;
    //state = &state_chip;      // init ptr
    si_state_info(stateBuf);
    *state_chip = stateBuf[0];
    //*state = stateBuf[0];                 // Sauvegarde de l'etat actuel    
    Serial.println("====================");
    Serial.println("Etat du device");
    Serial.println("CURR_STATE - CURRENT_CHANNEL");

    switch(stateBuf[0]){            // Verification de l'etat de la puce
        case 0 :  Serial.println("0 : Pas de changement d'etat");
                  break;                  
        case 1 :  Serial.println("1 : Sleep state");
                  break;                  
        case 2 :  Serial.println("2 : Spi Active state");
                  break;
        case 3 :  Serial.println("3 : Ready State");
                  break;                  
        case 4 :  Serial.println("4 : Another enumeration for Ready State");
                  break;                 
        case 5 :  Serial.println("5 : Tune state for TX");
                  break;
        case 6 :  Serial.println("6 : Tune state for RX");
                  break;
        case 7 :  Serial.println("7 : TX state");
                  break;
        case 8 :  Serial.println("8 : RX state");
                  break;   
        default: Serial.println("Default");
                 break;
    }
    Serial.print("Channel number : ");
    Serial.println(stateBuf[1] , HEX);   
    Serial.println("====================");
    Serial.println("   ");
    
}
// ==========================
